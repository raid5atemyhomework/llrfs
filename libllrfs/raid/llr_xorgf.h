/*
Copyright 2022 raid5atemyhomework

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#pragma once
#if !defined(RAID_LLR_XORGF_H_)
#define RAID_LLR_XORGF_H_

/*
This module provides a multiply-by-GF(2^8) function,
multiplying a vector of bytes of LLR_XORGF_BLOCK_SIZE
by a specific GF(2^8) element.
Then, the product is Galois-field-added (i.e. XORed)
to an accumulator vector.

The source file for this module is generated by a
separate program.
*/

/** LLR_XORGF_BLOCK_SIZE
 *
 * @brief The number of bytes that will be processed
 * by each call.
 * Must be a multiple of 64 for compatibility to
 * 64-bit processors.
 * If you intend to be compatible to 128-bit processors,
 * must be a multiple of 128.
 * If you intend to be compatible to 256-bit processors,
 * must be a multiple of 256.
 * Etc.
 * Note in particular that SIMD extensions (which the
 * compiler might be able to generate automatically) can
 * effectively make ostensibly 32-bit and 64-bit processors
 * act like 128-bit, 256-bit, or 512-bit processors.
 *
 * Changing this size will cause incompatibility, i.e. a
 * version compiled with a different block size will *not*
 * be able to read what another version produces!
 */
#define LLR_XORGF_BLOCK_SIZE 4096

/** llr_xorgf_acc_mul
 *
 * Multiply c to the entire byte vector, then add the result
 * to the output accumulator vector.
 *
 * @param acc - input/output, the accumulator vector.
 * The vector must be of LLR_XORGF_BLOCK_SIZE bytes.
 * This will be modified in-place: each element in a is
 * multiplied by c, then the product is added to the
 * corresponding element in this vector.
 * @param c - input, the `GF(2^8)` element to multiply to all
 * values in the vector.
 * @param a - input, the input byte vector.
 * The vector must be of LLR_XORGF_BLOCK_SIZE bytes.
 * This must *not* be the same vector as acc above.
 *
 * @desc This may be more convenient when following an
 * information dispersal matrix where successive columns
 * along a row might not be equal to some generator
 * raised to the column index.
 * Classic MD RAID6 and ZFS RAIDZ2/RAIDZ3 *are* equal
 * to a generator raised to the column index so those
 * would be more likely to use the inplace version.
 *
 * Remember that "add" here is Galois field add, i.e. XOR.
 */
void llr_xorgf_acc_mul(void* restrict acc, unsigned char c, void const* restrict a);

#endif /* !defined(RAID_LLR_XORGF_H_) */
